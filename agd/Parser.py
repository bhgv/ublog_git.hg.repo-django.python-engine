# -*- coding: utf8 -*-
#-------------------------------------------------------------------------
#Parser.py -- ATG file parser
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/

import sys

from Scanner import Token
from Scanner import Scanner
from Scanner import Position

class ErrorRec( object ):
   def __init__( self, l, c, s ):
      self.line   = l
      self.col    = c
      self.num    = 0
      self.str    = s


class Errors( object ):
   errMsgFormat = "file %(file)s : (%(line)d, %(col)d) %(text)s\n"
   eof          = False
   count        = 0         # number of errors detected
   fileName     = ''
   listName     = ''
   mergeErrors  = False
   mergedList   = None      # PrintWriter
   errors       = [ ]
   minErrDist   = 2
   errDist      = minErrDist
      # A function with prototype: f( errorNum=None ) where errorNum is a
      # predefined error number.  f returns a tuple, ( line, column, message )
      # such that line and column refer to the location in the 
      # source file most recently parsed.  message is the error
      # message corresponging to errorNum.

   @staticmethod
   def Init( parser, fn, dir, merge, getParsingPos, errorMessages ):
      Errors.theErrors = [ ]
      Errors.getParsingPos = getParsingPos
      Errors.errorMessages = errorMessages
      Errors.parser = parser
      Errors.fileName = fn
      listName = dir + 'listing.txt'
      Errors.mergeErrors = merge
      if Errors.mergeErrors:
         try:
            Errors.mergedList = open( listName, 'w' )
         except IOError:
            raise RuntimeError( '-- Compiler Error: could not open ' + listName )

   @staticmethod
   def storeError( line, col, s ):
      if Errors.mergeErrors:
         Errors.errors.append( ErrorRec( line, col, s ) )
      else:
         Errors.printMsg( Errors.fileName, line, col, s )

   @staticmethod
   def SynErr( errNum, errPos=None ):
      if errPos:
         line,col = errPos 
      else:
         line,col = Errors.getParsingPos( )
      msg = Errors.errorMessages[ errNum ]
      Errors.storeError( line, col, msg )
      Errors.count += 1

   @staticmethod
   def SemErr( errMsg, errPos=None ):
      if errPos:
         line,col = errPos 
      else:
         line,col = Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )
      Errors.count += 1

   @staticmethod
   def Warn( errMsg, errPos=None ):
      if errPos:
         line,col = errPos 
      else:
         line,col = Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )

   @staticmethod
   def Exception( errMsg ):
      print errMsg + "<br>"
      sys.exit( 1 )

   @staticmethod
   def printMsg( fileName, line, column, msg ):
      line0 = line - 30
      lines = Errors.parser.scanner.buffer.lines
      vals = { 'file':fileName, 'line':line, 'col':column, 'text':msg }

      if line0 < 1:
         line0 = 1
#      sys.stdout.write( 
      print "<br><CODE>"
#      )
      for lineN in xrange(line0, line):
         if lineN < len(lines):
#            sys.stdout.write( 
            print "%d. %s<br>" % (lineN+1, lines[lineN].rstrip()) 
#            )
#      sys.stdout.write( 
      print "%d. %s" % (line, "&nbsp;" * (column - 1) + "^<br>") 
#      )
      for lineN in xrange(line + 1, line + 3):
         if lineN < len(lines):
#            sys.stdout.write( 
            print "%d.. %s<br>" % (lineN+1, lines[lineN].rstrip())
#            )
#      sys.stdout.write( 
      print Errors.errMsgFormat % vals
#      )
#      sys.stdout.write( 
      print "<br></CODE>"
#      )

   @staticmethod
   def display( s, e ):
      Errors.mergedList.write('**** ')
      for c in xrange( 1, e.col ):
         if s[c-1] == '\t':
            Errors.mergedList.write( '\t' )
         else:
            Errors.mergedList.write( ' ' )
      Errors.mergedList.write( '^ ' + e.str + '\n')

   @staticmethod
   def Summarize( sourceBuffer ):
      if Errors.mergeErrors:     
         # Initialize the line iterator
         srcLineIter = iter(sourceBuffer)
         srcLineStr  = srcLineIter.next( )
         srcLineNum  = 1
         
         try:
            # Initialize the error iterator
            errIter = iter(Errors.errors)
            errRec  = errIter.next( )
            
            # Advance to the source line of the next error
            while srcLineNum < errRec.line:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )
               
               srcLineStr = srcLineIter.next( )
               srcLineNum += 1
            
            # Write out all errors for the current source line
            while errRec.line == srcLineNum:
               Errors.display( srcLineStr, errRec )
               
               errRec = errIter.next( )
         except:
            pass
         
         # No more errors to report
         try:
            # Advance to end of source file
            while True:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )
               
               srcLineStr = srcLineIter.next( )
               srcLineNum += 1
         except:
            pass
         
         Errors.mergedList.write( '\n' )
         Errors.mergedList.write( '%d errors detected\n' % Errors.count )
         Errors.mergedList.close( )
      
      sys.stdout.write( '<br><br><center><CODE>%d errors detected</CODE></center>' % Errors.count )
      if (Errors.count > 0) and Errors.mergeErrors:
         sys.stdout.write( 'see ' + Errors.listName + '\n' )


class Parser( object ):
   _EOF = 0
   _regular = 1
   _command = 2
   _cr = 3
   _number = 4
   maxT = 39

   T          = True
   x          = False
   minErrDist = 2

   import sys
   import os
   import os.path
   import re
   
   from lang.lng import VM

   from config import config
   from config.py_commands import py_commands

   lng = VM()
   
   text = u''

   commands = {}

   pars = []
   
   out_text = u""
   cur_par = 0
   
   loops = [0 for i in xrange(1000)]
   cur_loop = -1

   fixs = [0 for i in xrange(1000)]
   cur_fix = -1
   
   new_par = -1

   procs = []


   verb = 0

   
   def loadCommands( self ):
      cmd = u""
      b = u""
      e = u""
      v = u""
      par = False
      sngl = False
      f = open(self.config.config_path + "commands.txt", "r")
      if f == None:
         return
      for ln in f.readlines():
         ln = unicode(ln, "utf_8")
         if ln[0] == u'#':
            continue
         elif ln[0] == u"\\":
            if len(cmd) > 0 and cmd[0] == u"\\":
               self.commands[cmd] = {'b': b, 'e': e, 'v': v, 'par': par, 'single': sngl}
            cmd = ln.strip()
            b = u''
            e = u''
            v = u""
            par = False
            sngl = False
         elif ( ln[0] in (u'b', u'e', u'p', u's', u'v') ) and ln[1] == u':':
            l = (ln[2:]).strip()
            if ln[0] == u'b':
               b += u'' + l
            elif ln[0] == u'e':
               e += u'' + l
            elif ln[0] == u'v':
               #print l + " -- " + l[0:2]
               if l[0:2] == u'\\u':
                  if l[0:3] == u'\\ux':
                     v += unichr(int(l[3:], 16))
                  else:
                     v += unichr(int(l[2:]))
               else:
                  v += u'' + l
               #print v
            elif ln[0] == u'p':
               if len(l) > 0 and (l[0] == 'y' or l[0] == 'Y'):
#                  print "----> " + cmd
                  par = True
               else:
                  par = False
            elif ln[0] == u's':
               if len(l) > 0 and (l[0] == 'y' or l[0] == 'Y'):
#                  print "-s---> " + cmd
                  sngl = True
               else:
                  sngl = False
      f.close()
      if len(cmd) > 0 and cmd[0] == u"\\":
         self.commands[cmd] = {'b': b, 'e': e, 'v': v, 'par': par, 'single': sngl}
      if not self.commands.has_key( "\\page" ):
         self.commands["\\page"] = {'b': '', 'e': '', 'v': '', 'par': False, 'single': False}
      if not self.commands.has_key( "\\par" ):
         self.commands["\\par"] = {'b': '<br>', 'e': '', 'v': '', 'par': True, 'single': False}
#      print self.commands


   def EnterProc(self, name, pars, adrs):
      if len(pars) != len(adrs):
         self.SemErr(117)
      
      par_adrs = []
      for i in xrange(len(pars)):
         (par, foo) = pars[i]
         par_adrs.append( (par, foo, adrs[i]) );
      
      self.procs.append(par_adrs)
      return par_adrs

   def LeaveProc(self):
      last = len(self.procs) - 1
      del self.procs[ last ]
   
   def doCommand( self ):
      cmd = self.token.val
      obj = self.lng.GetObj( cmd )
      if obj is not self.lng.undefObj:
         type = obj['type']
         if obj['kind'] == self.lng.VARS:
            self.lng.Emit2(self.lng.RES, self.lng.DataSpace())         
            
            #self.lng.Emit3(self.lng.LOAD, self.lng.curLevel - obj['level'], obj['adr'])
            self.lng.Emit3(self.lng.LOAD, self.lng.curLevel - obj['level'], cmd)
            self.lng.Emit(self.lng.WRITE)
            
            self.new_par = 1
         elif obj['kind'] == self.lng.PROCS:
            cmd = cmd
            #print "PROCS"
            #self.lng.Emit3(self.lng.CALL, self.lng.curLevel - obj['level'], obj['adr']) 
            
            #self.new_par = 1

         #else: 
         #   self.SemErr(123) 
         return ( u'', u'', u'', False, True , obj)
      
      elif self.py_commands.has_key( cmd ):
         #self.lng.Emit2(self.lng.PY_CALL, self.py_commands[cmd])
         return ( u'', u'', u'', True, False , {'kind': self.lng.PY_MOD})

      elif self.commands.has_key( cmd ):
         #print "-----0> " + cmd
         #print self.commands[cmd].keys()
         return ( self.commands[cmd]['b'], self.commands[cmd]['e'], self.commands[cmd]['v'], self.commands[cmd]['par'], self.commands[cmd]['single'] , None )

      else:
         return ( cmd[1:], u'', cmd[1:], False, True , None )
         


   def newPar( self ):
      p = {'text': '', 'verb1': '', 'b': '', 'e': '', 'regular_par': True, 'par': False, 'cont_par':False, 'single': False}
      self.cur_par = len(self.pars);
      self.pars.append( p )
      self.lng.Emit2(self.lng.HTML_BLOCK, self.cur_par)
#      print "-p-> %d\n" % ( self.cur_par, )
      return p
      


#//IGNORECASE    


   def __init__( self ):
      self.scanner     = None
      self.token       = None           # last recognized token
      self.la          = None           # lookahead token
      self.genScanner  = False
      self.tokenString = ''             # used in declarations of literal tokens
      self.noString    = '-none-'       # used in declarations of literal tokens
      self.errDist     = Parser.minErrDist

   def getParsingPos( self ):
      return self.la.line, self.la.col

   def SynErr( self, errNum ):
      if self.errDist >= Parser.minErrDist:
         Errors.SynErr( errNum )

      self.errDist = 0

   def SemErr( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.SemErr( msg )

      self.errDist = 0

   def Warning( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.Warn( msg )
      
      self.errDist = 0

   def Successful( self ):
      return Errors.count == 0;

   def LexString( self ):
      return self.token.val

   def LookAheadString( self ):
      return self.la.val

   def Get( self ):
      while True:
         self.token = self.la
         self.la = self.scanner.Scan( )
         if self.la.kind <= Parser.maxT:
            self.errDist += 1
            break
         
         self.la = self.token

   def Expect( self, n ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )

   def StartOf( self, s ):
      return self.set[s][self.la.kind]

   def ExpectWeak( self, n, follow ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )
         while not self.StartOf(follow):
            self.Get( )

   def WeakSeparator( self, n, syFol, repFol ):
      s = [ False for i in xrange( Parser.maxT+1 ) ]
      if self.la.kind == n:
         self.Get( )
         return True
      elif self.StartOf(repFol):
         return False
      else:
         for i in xrange( Parser.maxT ):
            s[i] = self.set[syFol][i] or self.set[repFol][i] or self.set[0][i]
         self.SynErr( n )
         while not s[self.la.kind]:
            self.Get( )
         return self.StartOf( syFol )

   def Agd( self ):
      self.lng.out_text
      self.loadCommands()
      self.lng.tl_init()    
      self.lng.EnterScope() 
      par = self.newPar() 
      while self.StartOf(1):
         while not (self.StartOf(2)):
            self.SynErr(40)
            self.Get()
         par = self.BlockOuter(par)

      self.Expect(0)
      #print " end self.la.kind = %d, val = %s" % (self.la.kind, self.la.val) 
      self.lng.Emit(self.lng.HALTc)  
      self.lng.Interpret(self.pars, self.commands) 
      out = self.lng.get_out()
      if self.commands.has_key( "\\page" ):
         cmd = self.commands["\\page"]
         out['text'] = cmd['b'] + u'\n' + out['text'] + u'\n' + cmd['e'] + u'\n'
         self.py_commands['py_commands_reset']()
      return out 

   def BlockOuter( self, par ):
      if (self.la.kind == 3):
         self.Par()
         self.new_par = 0 
      if self.new_par >= 0:
         par = self.newPar()
         if self.new_par == 0:
            par['par'] = self.commands["\\par"]['par']
            par['regular_par'] = True
            par['cont_par'] = False
            par['b'] = u'' #self.commands["\\par"]['b']
            par['e'] = u'' #self.commands["\\par"]['e']
         else:
            par['par'] = False
            par['regular_par'] = False
            par['cont_par'] = True
            par['b'] = u''
            par['e'] = u''
         
         self.new_par = -1
      
      par = self.Block(par)
      return par

   def Par( self ):
      self.Expect(3)
      while self.la.kind == 3:
         self.Get( )


   def Block( self, par ):
      if self.StartOf(3):
         par = self.Command(par)
      elif self.la.kind == 5:
         self.Get( )
         while self.StartOf(1):
            while not (self.StartOf(2)):
               self.SynErr(41)
               self.Get()
            if (self.la.kind == 3):
               self.Get( )
               par['verb1'] += u'\n' 
            par = self.Block(par)

         self.Expect(6)
      elif self.StartOf(4):
         par = self.Atom(par)
      else:
         self.SynErr(42)
      if (self.la.kind == 3):
         self.Get( )
         par['text'] += u' ' 
         par['verb1'] += u'\n' 
      return par

   def Command( self, par ):
      if self.StartOf(5):
         par = self.Body(par)
      elif self.StartOf(6):
         if self.la.kind == 2:
            self.Get( )
         elif self.la.kind == 25:
            self.Get( )
         elif self.la.kind == 26:
            self.Get( )
         else:
            self.Get( )
         ( b, e, verb1, p, sngl, obj ) = self.doCommand() 
         sngl = not sngl 
         # print "==> " + self.token.val + ", " + str(p)
         name = self.token.val
         if p:
            par = self.newPar()
            par['b'] = b
            par['e'] = e
            par['par'] = p
            par['regular_par'] = False
         else:
            if b != None:
               par['text'] += b
               if verb1 != None and verb1 != '':
                  par['verb1'] += verb1
               else:
                  par['verb1'] += b
         
         if obj != None :
            if obj['kind'] == self.lng.PY_MOD :
               chnks = [] 
               adrs = [] 
               nadrs = [] 
               while self.la.kind == 5:
                  self.Get( )
                  if (self.la.kind == 3):
                     self.Get( )
                  par_fix = self.lng.pc + 1
                  self.lng.Emit2(self.lng.JMP, 0)
                  
                  par_adr = "L_%d" % (self.lng.pc,)
                  #print "! par_adr = %s" % (par_adr,)
                  o = self.lng.NewObj(par_adr, self.lng.PROCS)
                  o['adr'] = self.lng.pc
                  adrs.append( (o, par_adr) ) #self.lng.pc )
                  nadrs.append( self.lng.pc )
                  
                  self.lng.EnterScope() 
                  while self.StartOf(1):
                     while not (self.StartOf(2)):
                        self.SynErr(43)
                        self.Get()
                     self.new_par = 1 
                     par = self.BlockOuter(par)

                  self.Expect(6)
                  if (self.la.kind == 3):
                     self.Get( )
                  #self.scanner.buffer.setPos(b)
                  #t = self.scanner.buffer.ReadChars(e - b)
                  ##print t + "\n" 
                  #chnks.append( t )
                  
                  self.lng.LeaveScope() 
                  self.lng.Emit(self.lng.RET) 
                  self.lng.Fixup(par_fix) 

               #for (pnm, foo, adr) in par_adrs:
               #   print "o pnm = %s, foo = %d, adr = %d<br>" % (pnm, foo, adr)
               #i = len(chnks)
               i = len(nadrs)
               #for adr in chnks: #adrs:
               while i > 0: #adrs:
                  i -= 1
                  #self.lng.Emit2(self.lng.LIT, adrs[i])
                  
                  #(o, par_adr) = adrs[i]
                  self.lng.Emit(self.lng.TEXT_BEGIN)
                  self.lng.Emit2(self.lng.LIT, nadrs[i])
                  self.lng.Emit(self.lng.RCALL)
                  #self.lng.Emit4(self.lng.CALL, self.lng.curLevel - o['level'], par_adr)
                  self.lng.Emit(self.lng.TEXT_END)
                                 #j = len( self.lng.strings )
                  #self.lng.strings.append( chnks[i] )
                  #self.lng.Emit2(self.lng.LSTR, j)
               #i = len(chnks)
               i = len(nadrs)
                              #self.lng.Emit2(self.lng.LIT, i)
               #print "PY_MOD %s<br>" % (name,)
               
               self.lng.Emit3(self.lng.PY_CALL, self.py_commands[name], i) 
               self.new_par = 1 
            elif self.StartOf(7):
               if (obj['kind'] == self.lng.PROCS ):
                  i = len(obj['pars']) 
                  #print "proc %d<br>" % (i,) 
                  #adrs = [] 
                  nadrs = [] 
                  params_fix = self.lng.pc + 1
                  self.lng.Emit2(self.lng.JMP, 0)
                  
                  while i > 0 :
                     self.Get( )
                     if (self.la.kind == 3):
                        self.Get( )
                     #print "- %s par %d<br>" % (self.token.val, i,) 
                     par_adr = "L_%d" % (self.lng.pc,)
                     #print "! par_adr = %s" % (par_adr,)
                     #o = self.lng.NewObj(par_adr, self.lng.PROCS)
                     #o['adr'] = self.lng.pc
                     
                     #adrs.append( par_adr ) 
                     #nadrs.append( o['adr'] ) 
                     nadrs.append( self.lng.pc ) 
                     self.lng.EnterScope() 
                     while self.StartOf(1):
                        while not (self.StartOf(2)):
                           self.SynErr(44)
                           self.Get()
                        self.new_par = 1 
                        par = self.BlockOuter(par)

                     self.Expect(6)
                     if (self.la.kind == 3):
                        self.Get( )
                     self.lng.LeaveScope() 
                     self.lng.Emit(self.lng.RET) 
                     self.new_par = 1 
                     i -= 1      

                  #print "<br>" 
                  if i > 0:
                     self.SemErr(117)
                  
                  self.lng.Fixup(params_fix) 
                  par_adrs = self.EnterProc(name, obj['pars'], nadrs) 
                  #print "par_adrs = %s<br>" % (par_adrs, ) 
                  self.lng.EnterScope() 
                  #for (pnm, foo, adr) in par_adrs:
                  #   print "o pnm = %s, foo = %d, adr = %d<br>" % (pnm, foo, adr)
                  
                  for adr in nadrs:
                     self.lng.Emit2(self.lng.LIT, adr) 
                  
                  self.lng.Emit4(self.lng.CALL, self.lng.curLevel - obj['level'], name, par_adrs)
                  #self.lng.Emit4(self.lng.CALL, self.lng.curLevel - obj['level'], obj['adr'], par_adrs)
                  
                  self.lng.LeaveScope() 
                  self.LeaveProc() 
            else:
               self.SynErr(45)
         elif self.StartOf(7):
            if (sngl ):
               self.Get( )
               if (self.la.kind == 3):
                  self.Get( )
               while self.StartOf(1):
                  while not (self.StartOf(2)):
                     self.SynErr(46)
                     self.Get()
                  self.new_par = 1 
                  par = self.BlockOuter(par)

               self.Expect(6)
               if p:
                  par = self.newPar()
                  par['par'] = self.commands["\\par"]['par']
                  par['b'] = self.commands["\\par"]['b']
                  par['e'] = self.commands["\\par"]['e']
               elif e != None:
                  par['text'] += u'' + e
               
         else:
            self.SynErr(47)
      else:
         self.SynErr(48)
      return par

   def Atom( self, par ):
      #if self.verb == 1:
      b1 = self.token.pos + len(self.token.val)
      e1 = self.token.pos + len(self.token.val)
      
      if self.la.kind == 7:
         self.Get( )
         t = u'&lt;' 
         if (self.la.kind == 7):
            self.Get( )
            t = u'&laquo;' 
         par['text'] += t 
      elif self.la.kind == 8:
         self.Get( )
         t = u'&gt;' 
         if (self.la.kind == 8):
            self.Get( )
            t = u'&raquo;' 
         par['text'] += t 
      elif self.StartOf(8):
         if self.la.kind == 1:
            self.Get( )
         elif self.la.kind == 9:
            self.Get( )
         elif self.la.kind == 10:
            self.Get( )
         elif self.la.kind == 4:
            self.Get( )
         elif self.la.kind == 11:
            self.Get( )
         elif self.la.kind == 12:
            self.Get( )
         elif self.la.kind == 13:
            self.Get( )
         elif self.la.kind == 14:
            self.Get( )
         elif self.la.kind == 15:
            self.Get( )
         elif self.la.kind == 16:
            self.Get( )
         elif self.la.kind == 17:
            self.Get( )
         elif self.la.kind == 18:
            self.Get( )
         else:
            self.Get( )
         #if self.verb == 0: 
         b = self.token.pos
         e = self.token.pos + len(self.token.val)
         
         while self.StartOf(8):
            if self.la.kind == 1:
               self.Get( )
            elif self.la.kind == 9:
               self.Get( )
            elif self.la.kind == 10:
               self.Get( )
            elif self.la.kind == 4:
               self.Get( )
            elif self.la.kind == 11:
               self.Get( )
            elif self.la.kind == 12:
               self.Get( )
            elif self.la.kind == 13:
               self.Get( )
            elif self.la.kind == 14:
               self.Get( )
            elif self.la.kind == 15:
               self.Get( )
            elif self.la.kind == 16:
               self.Get( )
            elif self.la.kind == 17:
               self.Get( )
            elif self.la.kind == 18:
               self.Get( )
            else:
               self.Get( )

         #if self.verb == 0:
         e = self.token.pos + len(self.token.val)
         self.scanner.buffer.setPos(b)
         t = self.scanner.buffer.ReadChars(e - b)
         #print t + "\n" 
         par['text'] += u'' + t
         
      else:
         self.SynErr(49)
      while self.la.kind == 3:
         self.Get( )

      #if self.verb == 1:
      e1 = self.token.pos + len(self.token.val)
      self.scanner.buffer.setPos(b1)
      t = self.scanner.buffer.ReadChars(e1 - b1)
      #print t + "\n" 
      par['verb1'] += u'' + t
      
      return par

   def Table( self, par ):
      self.Expect(20)
      self.cur_fix += 1
      self.fixs[self.cur_fix] = self.lng.pc + 1
      
      self.lng.Emit2(self.lng.JMP, 0)
      
      #t_hd_pars = []
      t_aligns = []
      #t_lns = []
      
      tab_name_adr = "L_%d" % (self.lng.pc,)
      #print "tab_name_adr = %s" % (tab_name_adr,)
      o = self.lng.NewObj(tab_name_adr, self.lng.PROCS)
      o['adr'] = self.lng.pc
      
      if (self.la.kind == 3):
         self.Par()
      if (self.la.kind == 5):
         self.Get( )
         t_nm = self.newPar()
         t_nm['par'] = True
         t_nm['regular_par'] = False
         t_nm['cont_par'] = False
         t_nm['b'] = self.commands["\\table_name"]['b']
         t_nm['e'] = self.commands["\\table_name"]['e']
         
         if (self.StartOf(1)):
            t_nm = self.BlockOuter(t_nm)
         self.Expect(6)
         if (self.la.kind == 3):
            self.Par()
      self.lng.Emit(self.lng.RET)
      
      tab_hdr_adr = "L_%d" % (self.lng.pc,)
      #print "tab_hdr_adr = %s" % (tab_hdr_adr,)
      o = self.lng.NewObj(tab_hdr_adr, self.lng.PROCS)
      o['adr'] = self.lng.pc
      
      if (self.la.kind == 21):
         self.Get( )
         if (self.la.kind == 3):
            self.Par()
         
         t_hd_p = self.newPar()
         t_hd_p['par'] = False
         t_hd_p['regular_par'] = False
         t_hd_p['cont_par'] = True
         t_hd_p['b'] = ""
         t_hd_p['e'] = ""
         
         t_hd_p['text'] += self.commands["\\table_hdr_line"]['b']
         
         while self.la.kind == 5:
            self.Get( )
            t_hd_p = self.newPar()
            t_hd_p['par'] = False
            t_hd_p['regular_par'] = False
            t_hd_p['cont_par'] = True
            t_hd_p['b'] = ""
            t_hd_p['e'] = ""
            
            t_hd_p['text'] += self.commands["\\table_hdr_cell"]['b']
            
            if (self.StartOf(1)):
               t_hd_p = self.BlockOuter(t_hd_p)
            self.Expect(6)
            t_hd_p['text'] += self.commands["\\table_hdr_cell"]['e']
            
            if (self.la.kind == 3):
               self.Par()
         
         t_hd_p = self.newPar()
         t_hd_p['par'] = False
         t_hd_p['regular_par'] = False
         t_hd_p['cont_par'] = True
         t_hd_p['b'] = ""
         t_hd_p['e'] = ""
         
         t_hd_p['text'] += self.commands["\\table_hdr_line"]['e']

      self.lng.Emit(self.lng.RET)
      
      if (self.la.kind == 22):
         self.Get( )
         if (self.la.kind == 3):
            self.Par()
         self.Expect(5)
         while self.StartOf(9):
            if self.la.kind == 7:
               self.Get( )
            elif self.la.kind == 8:
               self.Get( )
            elif self.la.kind == 12:
               self.Get( )
            else:
               self.Get( )
            t_aligns.append(self.token.val)
            
            if (self.la.kind == 3):
               self.Par()

         self.Expect(6)
         if (self.la.kind == 3):
            self.Par()
      self.lng.Fixup(self.fixs[self.cur_fix])
      self.cur_fix -= 1
      
      par['text'] += self.commands["\\table_def"]['b']
      
      self.lng.Emit4(self.lng.CALL, self.lng.curLevel, tab_hdr_adr)
      
      par = self.newPar()
      par['par'] = False
      par['regular_par'] = False
      par['cont_par'] = True
      par['b'] = self.commands["\\table_line"]['b']
      par['e'] = self.commands["\\table_line"]['e']
      
      while self.la.kind == 23:
         self.Get( )
         par['text'] += self.commands["\\table_line"]['b']
         
         col = 0
         
         if (self.la.kind == 3):
            self.Par()
         while self.la.kind == 5:
            self.Get( )
            al = t_aligns[col]
            col += 1
            if   al == '<':
               cell_type = "\\table_cell_l"
            elif al == '>':
               cell_type = "\\table_cell_r"
            elif al == '.':
               cell_type = "\\table_cell_c"
            elif al == '-':
               cell_type = "\\table_cell_j"
            else:
               cell_type = "\\table_cell"
            par['text'] += self.commands[cell_type]['b']
            
            while self.StartOf(1):
               while not (self.StartOf(2)):
                  self.SynErr(50)
                  self.Get()
               self.new_par = 1 
               par = self.BlockOuter(par)

            par = self.newPar()
            par['par'] = False
            par['regular_par'] = False
            par['cont_par'] = True
            par['b'] = ""
            par['e'] = ""
            
            par['text'] += self.commands[cell_type]['e']
            
            self.Expect(6)
            if (self.la.kind == 3):
               self.Par()

         par['text'] += self.commands["\\table_line"]['e']
         

      self.Expect(24)
      par['text'] += self.commands["\\table_def"]['e']
      
      self.lng.Emit4(self.lng.CALL, self.lng.curLevel, tab_name_adr) 
      
      self.new_par = 0 
      return par

   def Body( self, par ):
      if self.la.kind == 28:
         self.Get( )
         self.Expect(5)
         self.Var()
         while self.la.kind == 13:
            self.Get( )
            if (self.la.kind == 2):
               self.Var()

         self.Expect(6)
      elif self.la.kind == 29:
         self.Get( )
         self.Expect(5)
         self.Exprs()
         self.Expect(6)
      elif self.la.kind == 30:
         par = self.Def(par)
      elif self.la.kind == 32:
         par = self.If(par)
      elif self.la.kind == 35:
         par = self.For(par)
      elif self.la.kind == 20:
         par = self.Table(par)
      else:
         self.SynErr(51)
      return par

   def Var( self ):
      self.Expect(2)
      obj = self.lng.NewObj(self.token.val, self.lng.VARS)        

   def Exprs( self ):
      self.Expr()
      while self.la.kind == 13:
         self.Get( )
         if (self.la.kind == 2):
            self.Expr()


   def Def( self, par ):
      self.Expect(30)
      #self.cur_fix += 1
      #self.fixs[self.cur_fix]
      def_fix = self.lng.pc + 1
      
      self.lng.Emit2(self.lng.JMP, 0)
      
      self.Expect(5)
      name = self.Ident()
      obj = self.lng.NewObj(name, self.lng.PROCS)
      obj['adr'] = self.lng.pc
      
      self.Expect(6)
      self.lng.EnterScope() 
      while self.la.kind == 5:
         self.Get( )
         self.Expect(2)
         pnm = self.token.val 
         o = self.lng.NewObj(pnm, self.lng.PROCS)
         o['adr'] = 0
         
         obj['pars'].append( (pnm, o['adr']) ) 
         #print "o = self.lng.NewObj(%s, self.lng.VARS)<br>%s<br>" % (name[1:], o) 
         #self.lng.LeaveScope()
         #self.lng.Emit(self.lng.RET)
         
         self.Expect(6)

      while self.StartOf(1):
         while not (self.StartOf(2)):
            self.SynErr(52)
            self.Get()
         self.new_par = 1 
         par = self.BlockOuter(par)

      self.Expect(31)
      self.lng.LeaveScope()
      self.lng.Emit(self.lng.RET)
      
      self.new_par = 1 
      self.lng.Fixup(def_fix)
      #self.lng.Fixup(self.fixs[self.cur_fix])
      #self.cur_fix -= 1
      
      return par

   def If( self, par ):
      self.Expect(32)
      self.Expect(5)
      type = self.Expression()
      if type != self.lng.BOOL:
          self.SemErr(122)
      
      self.cur_fix += 1
      self.fixs[self.cur_fix] = self.lng.pc + 1
      
      self.lng.Emit2(self.lng.FJMP, 0)                  
      
      self.Expect(6)
      self.lng.EnterScope() 
      self.new_par = 1 
      while self.StartOf(1):
         while not (self.StartOf(2)):
            self.SynErr(53)
            self.Get()
         par = self.BlockOuter(par)

      self.Expect(33)
      self.lng.LeaveScope() 
      fix_over_else_part = self.lng.pc + 1
      self.lng.Emit2(self.lng.JMP, 0)                   
      
      self.lng.Fixup(self.fixs[self.cur_fix])
      self.fixs[self.cur_fix] = fix_over_else_part
      
      self.lng.EnterScope() 
      self.new_par = 1 
      while self.StartOf(1):
         while not (self.StartOf(2)):
            self.SynErr(54)
            self.Get()
         par = self.BlockOuter(par)

      self.Expect(34)
      self.lng.LeaveScope() 
      self.lng.Fixup(self.fixs[self.cur_fix])
      self.cur_fix -= 1
      
      self.new_par = 1 
      return par

   def For( self, par ):
      self.Expect(35)
      self.Expect(5)
      if (self.la.kind == 2):
         self.Exprs()
      self.Expect(14)
      adr_of_if_part = self.lng.pc 
      type = self.Expression()
      #if type != self.lng.BOOL:
       #   self.SemErr(122) 
      
      self.cur_fix += 1
      self.fixs[self.cur_fix] = self.lng.pc + 1
      
      self.lng.Emit2(self.lng.FJMP, 0)                   
      
      fix_to_body_part = self.lng.pc + 1
      self.lng.Emit2(self.lng.JMP, 0)                   
      
      self.Expect(14)
      self.cur_loop += 1
      self.loops[self.cur_loop] = self.lng.pc       
      
      if (self.la.kind == 2):
         self.Exprs()
      self.lng.Emit2(self.lng.JMP, adr_of_if_part) 
      self.Expect(6)
      self.lng.Fixup(fix_to_body_part) 
      self.lng.EnterScope() 
      self.new_par = 1      
      while self.StartOf(1):
         while not (self.StartOf(2)):
            self.SynErr(55)
            self.Get()
         par = self.BlockOuter(par)

      self.Expect(36)
      self.lng.LeaveScope() 
      self.lng.Emit2(self.lng.JMP, self.loops[self.cur_loop])
      self.cur_loop -= 1
      
      self.lng.Fixup(self.fixs[self.cur_fix])
      self.cur_fix -= 1
      
      self.new_par = 1 
      return par

   def Ident( self ):
      self.Expect(2)
      name = self.token.val 
      return name

   def Expression( self ):
      type = self.SimExpr()
      if (self.la.kind == 7 or self.la.kind == 8 or self.la.kind == 11):
         op = self.RelOp()
         type1 = self.SimExpr()
         #if type != type1: 
         #   self.SemErr(121)
         self.lng.Emit(op)
         type = self.lng.BOOL 
         
      return type

   def Expr( self ):
      self.lng.Emit2(self.lng.RES, self.lng.DataSpace()) 
      name = self.Ident()
      obj = self.lng.Obj(name) 
      self.Expect(15)
      type = self.Expression()
      if obj['kind'] == self.lng.VARS:
         obj['type'] = type
         #self.lng.Emit3(self.lng.STO, self.lng.curLevel - obj['level'], obj['adr']) 
         self.lng.Emit3(self.lng.STO, self.lng.curLevel - obj['level'], name) 
      

   def SimExpr( self ):
      type = self.Term()
      while self.la.kind == 16 or self.la.kind == 17:
         op = self.AddOp()
         type1 = self.Term()
         #if type != self.lng.INT or type1 != self.lng.INT: 
         #   self.SemErr(120)
         self.lng.Emit(op)
         

      return type

   def RelOp( self ):
      op = -1; 
      if self.la.kind == 11:
         self.Get( )
         op = self.lng.EQU 
      elif self.la.kind == 7:
         self.Get( )
         op = self.lng.LSS 
      elif self.la.kind == 8:
         self.Get( )
         op = self.lng.GTR 
      else:
         self.SynErr(56)
      return op

   def Term( self ):
      type = self.Factor()
      while self.la.kind == 18 or self.la.kind == 19:
         op = self.MulOp()
         type1 = self.Factor()
         #if type != self.lng.INT or type1 != self.lng.INT: 
         #   self.SemErr(120)
         self.lng.Emit(op)
         

      return type

   def AddOp( self ):
      op = -1; 
      if self.la.kind == 17:
         self.Get( )
         op = self.lng.ADD #PLUS 
      elif self.la.kind == 16:
         self.Get( )
         op = self.lng.SUB #MINUS 
      else:
         self.SynErr(57)
      return op

   def Factor( self ):
      name = ""
      type = ""
      
      if self.la.kind == 2:
         name = self.Ident()
         obj = self.lng.Obj(name) 
         type = obj['type']
         if obj['kind'] == self.lng.VARS:
            #self.lng.Emit3(self.lng.LOAD, self.lng.curLevel - obj['level'], obj['adr'])
            self.lng.Emit3(self.lng.LOAD, self.lng.curLevel - obj['level'], name)
         else: 
            self.SemErr(123) 
         
      elif self.la.kind == 37:
         self.Get( )
         self.lng.Emit2(self.lng.LIT, 1) 
         type = self.lng.BOOL 
         
      elif self.la.kind == 38:
         self.Get( )
         self.lng.Emit2(self.lng.LIT, 0) 
         type = self.lng.BOOL 
         
      elif self.la.kind == 4:
         self.Get( )
         name = self.token.val
         n = float(name)
         if n == round(n):
            n = int(n)
         #print "~~ %f" % (n,)
         self.lng.Emit2(self.lng.LIT, n) 
         type = self.lng.INT
         
      elif self.la.kind == 9 or self.la.kind == 10:
         if self.la.kind == 10:
            self.Get( )
            while self.la.kind == 1 or self.la.kind == 4 or self.la.kind == 9:
               if self.la.kind == 1:
                  self.Get( )
               elif self.la.kind == 9:
                  self.Get( )
               else:
                  self.Get( )
               name += self.token.val 

            self.Get( )
         else:
            self.Get( )
            while self.la.kind == 1 or self.la.kind == 4 or self.la.kind == 10:
               if self.la.kind == 1:
                  self.Get( )
               elif self.la.kind == 10:
                  self.Get( )
               else:
                  self.Get( )
               name += self.token.val 

            self.Get( )
         i = len( self.lng.strings )
         self.lng.strings.append( name )
         self.lng.Emit2(self.lng.LSTR, i)
         type = self.lng.STRING 
         
      elif self.la.kind == 16:
         self.Get( )
         type = self.Factor()
         #if type != self.lng.INT:
         #   self.SemErr(120) 
         type = self.lng.INT
         self.lng.Emit(self.lng.NEG)
         
      else:
         self.SynErr(58)
      return type

   def MulOp( self ):
      op = -1 
      if self.la.kind == 19:
         self.Get( )
         op = self.lng.MUL #TIMES 
      elif self.la.kind == 18:
         self.Get( )
         op = self.lng.DIVI #SLASH 
      else:
         self.SynErr(59)
      return op



   def Parse( self, scanner ):
      self.scanner = scanner
      self.la = Token( )
      self.la.val = u''
      self.Get( )
      out = self.Agd()
      self.Expect(0)
      return u'<style type="text/css">\n%s\n</style>\n%s\n' % (out['css'], out['text'])


   set = [
      [T,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, x,T,T,T, T,T,T,x, T,x,x,T, x,x,x,x, x],
      [x,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, x,T,T,T, T,T,T,x, T,x,x,T, x,x,x,x, x],
      [T,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, x,T,T,T, T,T,T,x, T,x,x,T, x,x,x,x, x],
      [x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,T,T, T,T,T,x, T,x,x,T, x,x,x,x, x],
      [x,T,x,x, T,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x],
      [x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,T,x, T,x,x,T, x,x,x,x, x],
      [x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x],
      [T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, x,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, x],
      [x,T,x,x, T,x,x,x, x,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x],
      [x,x,x,x, x,x,x,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x]

      ]

   errorMessages = {
      
      0 : "EOF expected",
      1 : "regular expected",
      2 : "command expected",
      3 : "cr expected",
      4 : "number expected",
      5 : "\"{\" expected",
      6 : "\"}\" expected",
      7 : "\"<\" expected",
      8 : "\">\" expected",
      9 : "\"\'\" expected",
      10 : "\"\"\" expected",
      11 : "\"==\" expected",
      12 : "\".\" expected",
      13 : "\",\" expected",
      14 : "\";\" expected",
      15 : "\"=\" expected",
      16 : "\"-\" expected",
      17 : "\"+\" expected",
      18 : "\"/\" expected",
      19 : "\"*\" expected",
      20 : "\"\\\\table\" expected",
      21 : "\"\\\\header\" expected",
      22 : "\"\\\\align\" expected",
      23 : "\"\\\\row\" expected",
      24 : "\"\\\\endtable\" expected",
      25 : "\"\\\\\\\\\" expected",
      26 : "\"\\\\{\" expected",
      27 : "\"\\\\}\" expected",
      28 : "\"\\\\var\" expected",
      29 : "\"\\\\let\" expected",
      30 : "\"\\\\def\" expected",
      31 : "\"\\\\enddef\" expected",
      32 : "\"\\\\if\" expected",
      33 : "\"\\\\else\" expected",
      34 : "\"\\\\endif\" expected",
      35 : "\"\\\\for\" expected",
      36 : "\"\\\\endfor\" expected",
      37 : "\"true\" expected",
      38 : "\"false\" expected",
      39 : "??? expected",
      40 : "this symbol not expected in Agd",
      41 : "this symbol not expected in Block",
      42 : "invalid Block",
      43 : "this symbol not expected in Command",
      44 : "this symbol not expected in Command",
      45 : "invalid Command",
      46 : "this symbol not expected in Command",
      47 : "invalid Command",
      48 : "invalid Command",
      49 : "invalid Atom",
      50 : "this symbol not expected in Table",
      51 : "invalid Body",
      52 : "this symbol not expected in Def",
      53 : "this symbol not expected in If",
      54 : "this symbol not expected in If",
      55 : "this symbol not expected in For",
      56 : "invalid RelOp",
      57 : "invalid AddOp",
      58 : "invalid Factor",
      59 : "invalid MulOp",
      }


